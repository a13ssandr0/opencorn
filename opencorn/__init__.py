from typing import NamedTuple
from serial import Serial
from enum import IntEnum

AccelerometerChannelsCount = 3
AccelerometerConfigIndex = 8
BatteryConfigIndex = 14
CounterConfigIndex = 15
DeviceVersionLengthMax = 6
EEGChannelsCount = 8
EEGConfigIndex = 0
ErrorBluetoothInitFailed = 2
ErrorBluetoothSocketFailed = 3
ErrorBufferOverflow = 6
ErrorBufferUnderflow = 7
ErrorConnectionProblem = 9
ErrorInvalidConfiguration = 5
ErrorInvalidHandle = -2
ErrorInvalidParameter = 1
ErrorOpenDeviceFailed = 4
ErrorOperationNotAllowed = 8
ErrorSuccess = 0
ErrorUnknownError = -1
ErrorUnsupportedDevice = 10
FirmwareVersionLengthMax = 12
GyroscopeChannelsCount = 3
GyroscopeConfigIndex = 11
NumberOfDigitalOutputs = 8
RecommendedBluetoothDeviceManufacturer = 'Cambridge Silicon Radio Ltd.'
RecommendedBluetoothDeviceName = 'CSR8510 A10'
SamplingRate = 250
SerialLengthMax = 14
StringLengthMax = 255
SupportedDeviceVersion = '1.'
TotalChannelsCount = 17
ValidationConfigIndex = 1


_led_chksums = [
    (0xe4, 0xe1), (0xf4, 0xc0), (0xc4, 0xa3), (0xd4, 0x82), (0xa4, 0x65), (0xb4, 0x44), (0x84, 0x27), (0x94, 0x06),
    (0x65, 0xe9), (0x75, 0xc8), (0x45, 0xab), (0x55, 0x8a), (0x25, 0x6d), (0x35, 0x4c), (0x05, 0x2f), (0x15, 0x0e),
    (0xf6, 0xd0), (0xe6, 0xf1), (0xd6, 0x92), (0xc6, 0xb3), (0xb6, 0x54), (0xa6, 0x75), (0x96, 0x16), (0x86, 0x37),
    (0x77, 0xd8), (0x67, 0xf9), (0x57, 0x9a), (0x47, 0xbb), (0x37, 0x5c), (0x27, 0x7d), (0x17, 0x1e), (0x07, 0x3f),
    (0xc0, 0x83), (0xd0, 0xa2), (0xe0, 0xc1), (0xf0, 0xe0), (0x80, 0x07), (0x90, 0x26), (0xa0, 0x45), (0xb0, 0x64),
    (0x41, 0x8b), (0x51, 0xaa), (0x61, 0xc9), (0x71, 0xe8), (0x01, 0x0f), (0x11, 0x2e), (0x21, 0x4d), (0x31, 0x6c),
    (0xd2, 0xb2), (0xc2, 0x93), (0xf2, 0xf0), (0xe2, 0xd1), (0x92, 0x36), (0x82, 0x17), (0xb2, 0x74), (0xa2, 0x55),
    (0x53, 0xba), (0x43, 0x9b), (0x73, 0xf8), (0x63, 0xd9), (0x13, 0x3e), (0x03, 0x1f), (0x33, 0x7c), (0x23, 0x5d),
    (0xac, 0x25), (0xbc, 0x04), (0x8c, 0x67), (0x9c, 0x46), (0xec, 0xa1), (0xfc, 0x80), (0xcc, 0xe3), (0xdc, 0xc2),
    (0x2d, 0x2d), (0x3d, 0x0c), (0x0d, 0x6f), (0x1d, 0x4e), (0x6d, 0xa9), (0x7d, 0x88), (0x4d, 0xeb), (0x5d, 0xca),
    (0xbe, 0x14), (0xae, 0x35), (0x9e, 0x56), (0x8e, 0x77), (0xfe, 0x90), (0xee, 0xb1), (0xde, 0xd2), (0xce, 0xf3),
    (0x3f, 0x1c), (0x2f, 0x3d), (0x1f, 0x5e), (0x0f, 0x7f), (0x7f, 0x98), (0x6f, 0xb9), (0x5f, 0xda), (0x4f, 0xfb),
    (0x88, 0x47), (0x98, 0x66), (0xa8, 0x05), (0xb8, 0x24), (0xc8, 0xc3), (0xd8, 0xe2), (0xe8, 0x81), (0xf8, 0xa0),
    (0x09, 0x4f), (0x19, 0x6e), (0x29, 0x0d), (0x39, 0x2c), (0x49, 0xcb), (0x59, 0xea), (0x69, 0x89), (0x79, 0xa8),
    (0x9a, 0x76), (0x8a, 0x57), (0xba, 0x34), (0xaa, 0x15), (0xda, 0xf2), (0xca, 0xd3), (0xfa, 0xb0), (0xea, 0x91),
    (0x1b, 0x7e), (0x0b, 0x5f), (0x3b, 0x3c), (0x2b, 0x1d), (0x5b, 0xfa), (0x4b, 0xdb), (0x7b, 0xb8), (0x6b, 0x99),
    (0x75, 0x69), (0x65, 0x48), (0x55, 0x2b), (0x45, 0x0a), (0x35, 0xed), (0x25, 0xcc), (0x15, 0xaf), (0x05, 0x8e),
    (0xf4, 0x61), (0xe4, 0x40), (0xd4, 0x23), (0xc4, 0x02), (0xb4, 0xe5), (0xa4, 0xc4), (0x94, 0xa7), (0x84, 0x86),
    (0x67, 0x58), (0x77, 0x79), (0x47, 0x1a), (0x57, 0x3b), (0x27, 0xdc), (0x37, 0xfd), (0x07, 0x9e), (0x17, 0xbf),
    (0xe6, 0x50), (0xf6, 0x71), (0xc6, 0x12), (0xd6, 0x33), (0xa6, 0xd4), (0xb6, 0xf5), (0x86, 0x96), (0x96, 0xb7),
    (0x51, 0x0b), (0x41, 0x2a), (0x71, 0x49), (0x61, 0x68), (0x11, 0x8f), (0x01, 0xae), (0x31, 0xcd), (0x21, 0xec),
    (0xd0, 0x03), (0xc0, 0x22), (0xf0, 0x41), (0xe0, 0x60), (0x90, 0x87), (0x80, 0xa6), (0xb0, 0xc5), (0xa0, 0xe4),
    (0x43, 0x3a), (0x53, 0x1b), (0x63, 0x78), (0x73, 0x59), (0x03, 0xbe), (0x13, 0x9f), (0x23, 0xfc), (0x33, 0xdd),
    (0xc2, 0x32), (0xd2, 0x13), (0xe2, 0x70), (0xf2, 0x51), (0x82, 0xb6), (0x92, 0x97), (0xa2, 0xf4), (0xb2, 0xd5),
    (0x3d, 0xad), (0x2d, 0x8c), (0x1d, 0xef), (0x0d, 0xce), (0x7d, 0x29), (0x6d, 0x08), (0x5d, 0x6b), (0x4d, 0x4a),
    (0xbc, 0xa5), (0xac, 0x84), (0x9c, 0xe7), (0x8c, 0xc6), (0xfc, 0x21), (0xec, 0x00), (0xdc, 0x63), (0xcc, 0x42),
    (0x2f, 0x9c), (0x3f, 0xbd), (0x0f, 0xde), (0x1f, 0xff), (0x6f, 0x18), (0x7f, 0x39), (0x4f, 0x5a), (0x5f, 0x7b),
    (0xae, 0x94), (0xbe, 0xb5), (0x8e, 0xd6), (0x9e, 0xf7), (0xee, 0x10), (0xfe, 0x31), (0xce, 0x52), (0xde, 0x73),
    (0x19, 0xcf), (0x09, 0xee), (0x39, 0x8d), (0x29, 0xac), (0x59, 0x4b), (0x49, 0x6a), (0x79, 0x09), (0x69, 0x28),
    (0x98, 0xc7), (0x88, 0xe6), (0xb8, 0x85), (0xa8, 0xa4), (0xd8, 0x43), (0xc8, 0x62), (0xf8, 0x01), (0xe8, 0x20),
    (0x0b, 0xfe), (0x1b, 0xdf), (0x2b, 0xbc), (0x3b, 0x9d), (0x4b, 0x7a), (0x5b, 0x5b), (0x6b, 0x38), (0x7b, 0x19),
    (0x8a, 0xf6), (0x9a, 0xd7), (0xaa, 0xb4), (0xba, 0x95), (0xca, 0x72), (0xda, 0x53), (0xea, 0x30), (0xfa, 0x11)
]

class DeviceInformation():
    NumberOfEegChannels: int
    SerialNum: str
    FwVersion: str
    DeviceVersion: str
    PcbVersion: str
    EnclosureVersion: str


class CaptureData(NamedTuple):
    battery: int
    '''Battery level in percent'''

    eeg1: int
    '''EEG channel 1 in microvolts'''
    eeg2: int
    '''EEG channel 2 in microvolts'''
    eeg3: int
    '''EEG channel 3 in microvolts'''
    eeg4: int
    '''EEG channel 4 in microvolts'''
    eeg5: int
    '''EEG channel 5 in microvolts'''
    eeg6: int
    '''EEG channel 6 in microvolts'''
    eeg7: int
    '''EEG channel 7 in microvolts'''
    eeg8: int
    '''EEG channel 8 in microvolts'''

    accX: int
    '''Accelerometer X in g'''
    accY: int
    '''Accelerometer Y in g'''
    accZ: int
    '''Accelerometer Z in g'''

    gyrX: int
    '''Gyroscope X in deg/s'''
    gyrY: int
    '''Gyroscope Y in deg/s'''
    gyrZ: int
    '''Gyroscope Z in deg/s'''
    
    counter: int
    '''Sample counter'''

# https://github.com/unicorn-bi/Unicorn-Suite-Hybrid-Black/blob/master/Unicorn%20Bluetooth%20Protocol/UnicornBluetoothProtocol.pdf
def parse_capture(payload: bytes):
    payload = list(payload)

    # get battery level in percent
    data = [100 * (payload[2] & 0xF) / 15]

    # get eeg in microvolts
    for i in range(3,25,3):
        eeg = payload[i] << 16 | payload[i+1] << 8 | payload[i+2]
        # check if first bit is 1 (2s complement)
        if eeg &   0x00800000:
            eeg |= 0xFF000000
        # convert to eeg value in microvolts
        data.append(eeg * 4500000/50331642)

    # get accelerometer x,y,z in g
    for i in range(27, 32, 2):
        acc = (payload[i] | payload[i+1]<<8)
        if acc &   0x008000:
            acc -= 1<<16
        data.append(acc / 4096)

    # get gyroscope x,y,z in deg/s
    for i in range(33, 38, 2):
        gyr = (payload[i] | payload[i+1]<<8)
        if gyr &   0x008000:
            gyr -= 1<<16
        data.append(gyr / 32.8)

    # get counter
    data.append(payload[39] | payload[40] << 8 | payload[41] << 16 | payload[42] << 24)

    return CaptureData(*data)


class Unicorn():

    def __init__(self, port_dev, **kwargs) -> None:
        self._port_dev = port_dev
        self._serial = Serial(self._port_dev, **kwargs)

    def close(self):
        self._serial.close()

    def __enter__(self):
        self._serial.__enter__()
        self._serial.write(b'\x65\x3c\x03')
        self._serial.flush()
        dev_info = self._serial.read(45).strip(b'\x00').split(b'\x00')
        self.device_information = DeviceInformation()
        self.device_information.NumberOfEegChannels = int.from_bytes(dev_info[0])
        self.device_information.SerialNum = dev_info[1]
        self.device_information.FwVersion = dev_info[2]
        self.device_information.DeviceVersion = dev_info[3]
        self.device_information.PcbVersion = dev_info[4]
        self.device_information.EnclosureVersion = dev_info[5]
        return self

    def __exit__(self, *args, **kwargs):
        self._serial.__exit__(*args, **kwargs)
    
    def StartAcquisition(self):
        self._serial.write(b'\x61\x7c\x87')
        self._serial.flush()
        self._serial.read(3)
        self.__capture = True

    def GetData(self):
        while self.__capture:
            # yield self._serial.read_until(b'\x0D\x0A', 45)
            yield self._serial.read(45)

    def StopAcquisition(self):
        self.__capture = False
        self._serial.write(b'\x63\x5c\xc5')
        self._serial.flush()
        self._serial.read(3)

    def GetDigitalOutputs(self):
        self._serial.write(b'\x6b\xdd\xcd')
        self._serial.flush()
        data = self._serial.read(4)[1] # returns 4 bytes: 00 <led_data> <chsum1> <chsum2>
        return data
    
    def SetDigitalOutputs(self, data: int):
        self._serial.write([0x6a, data, *_led_chksums[data]])
        self._serial.flush()
    

def GetChannelIndex(name:str):
    return ChannelIndex[name.replace(' ', '_')].value

class ChannelIndex(IntEnum):
    EEG_1 = 0
    EEG_2 = 1
    EEG_3 = 2
    EEG_4 = 3
    EEG_5 = 4
    EEG_6 = 5
    EEG_7 = 6
    EEG_8 = 7
    Accelerometer_X = 8
    Accelerometer_Y = 9
    Accelerometer_Z = 10
    Gyroscope_X = 11
    Gyroscope_Y = 12
    Gyroscope_Z = 13
    Counter = 14
    Battery_Level = 15
    Validation_Indicator = 16



if __name__ == '__main__':
    print('Payload parser test')
    payload = [0xC0, 0x00, 0x0F, 0x00, 0x9F, 0xAF, 0x00, 0x9F, 0xD4, 0x00, 0xA0,
               0x40, 0x00, 0x9F, 0x43, 0x00, 0x9F, 0x9A, 0x00, 0x9F, 0xE3, 0x00,
               0x9F, 0x85, 0x00, 0x9F, 0xBB, 0x2E, 0xF6, 0xE9, 0x02, 0x8D, 0xF2,
               0xF3, 0xFF, 0xEF, 0xFF, 0x23, 0x00, 0xB0, 0x00, 0x00, 0x00, 0x0D, 0x0A]
    
    from pprint import pprint
    cd = parse_capture(payload)
    cd.gyrX
    pprint(cd._asdict())